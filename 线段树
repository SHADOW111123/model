线段树模板1
第一行包含两个整数 n,m，分别表示该数列数字的个数和操作的总个数。
第二行包含 n 个用空格分隔的整数 ai ，其中第 i 个数字表示数列第 i 项的初始值。
接下来 m 行每行包含 3 或 4 个整数，表示一个操作，具体如下：
1 x y k：将区间 [x,y] 内每个数加上 k。
2 x y：输出区间 [x,y] 内每个数的和。

区间和，每个区间加k
#include <iostream>
using LL = long long;
LL n, a[100005];
LL d[400020];//d[p]为p结点管制的区间和
LL b[400020];//lazy标记数组

void build(LL l, LL r, LL p) 
{  // l:区间左端点 r:区间右端点 p:节点标号
    if (l == r) {
        d[p] = a[l];  // 将节点赋值
        return;
    }
    LL m = l + ((r - l) >> 1);
    build(l, m, p << 1);
    build(m + 1, r, (p << 1) +1);  // 分别建立子树
    d[p] = d[p << 1] + d[(p << 1) + 1];
}

void update(LL l, LL r, LL c, LL s, LL t, LL p) 
{
    if (l <= s && t <= r) {
        d[p] += (t - s + 1) * c, b[p] += c;  // 如果区间被包含了，直接得出答案
        return;
    }
    LL m = s + ((t - s) >> 1);
    if (b[p])
    {
        d[p << 1] += b[p] * (m - s + 1);
        d[(p << 1) + 1] += b[p] * (t - m);
        b[p << 1] += b[p];
        b[(p << 1) + 1] += b[p];
        b[p] = 0;
    }
  
    if (l <= m)
        update(l, r, c, s, m, p << 1);  // 本行和下面的一行用来更新p*2和p*2+1的节点
    if (r > m) update(l, r, c, m + 1, t, (p << 1) | 1);
    d[p] = d[p << 1] + d[(p << 1) | 1];  // 计算该节点区间和
}

LL getsum(LL l, LL r, LL s, LL t, LL p) 
{
    if (l <= s && t <= r) return d[p];
    LL m = s + ((t - s) >> 1);
    if (b[p])
    {
        d[p << 1] += b[p] * (m - s + 1);
        d[(p << 1) + 1] += b[p] * (t - m);
        b[p << 1] += b[p];
        b[(p << 1) + 1] += b[p];
    b[p] = 0;
    }
    LL sum = 0;
    if (l <= m)
        sum += getsum(l, r, s, m, p << 1);  // 本行和下面的一行用来更新p*2和p*2+1的答案
    if (r > m) sum += getsum(l, r, m + 1, t, (p << 1) | 1);
    return sum;
}

int main() 
{
    std::ios::sync_with_stdio(false);
    LL q, i1, i2, i3, i4;
    std::cin >> n >> q;
    for (LL i = 1; i <= n; i++) 
        std::cin >> a[i];
    build(1, n, 1);
    while (q--) {
        std::cin >> i1 >> i2 >> i3;
        if (i1 == 2)
            std::cout << getsum(i2, i3, 1, n, 1) << std::endl;  //在[1,n]查询[i2,i3]的区间和
        else
            std::cin >> i4, update(i2, i3, i4, 1, n, 1);//[1,n]区间内[i2,i3]加上i4
    }
    return 0;
}







区间积，每个区间乘k
#include <iostream>
using LL = long long;

const LL N = 100005;
const LL MOD = 1e9 + 7;

LL n, a[N];
LL d[N * 4];  // 区间积
LL b[N * 4];  // 懒标记（乘法）

LL qpow(LL a, LL b) {
    LL res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

void build(LL l, LL r, LL p) {
    b[p] = 1;  // 初始乘法懒标记为1
    if (l == r) {
        d[p] = a[l] % MOD;
        return;
    }
    LL m = (l + r) >> 1;
    build(l, m, p << 1);
    build(m + 1, r, p << 1 | 1);
    d[p] = d[p << 1] * d[p << 1 | 1] % MOD;
}

void update(LL l, LL r, LL c, LL s, LL t, LL p) {
    if (l <= s && t <= r) {
        d[p] = d[p] * qpow(c, t - s + 1) % MOD;
        b[p] = b[p] * c % MOD;
        return;
    }

    // 内联 pushdown
    LL m = (s + t) >> 1;
    if (b[p] != 1) {
        d[p << 1] = d[p << 1] * qpow(b[p], m - s + 1) % MOD;
        d[p << 1 | 1] = d[p << 1 | 1] * qpow(b[p], t - m) % MOD;
        b[p << 1] = b[p << 1] * b[p] % MOD;
        b[p << 1 | 1] = b[p << 1 | 1] * b[p] % MOD;
        b[p] = 1;
    }

    if (l <= m) update(l, r, c, s, m, p << 1);
    if (r > m) update(l, r, c, m + 1, t, p << 1 | 1);
    d[p] = d[p << 1] * d[p << 1 | 1] % MOD;
}

LL getsum(LL l, LL r, LL s, LL t, LL p) {
    if (l <= s && t <= r) return d[p];

    // 内联 pushdown
    LL m = (s + t) >> 1;
    if (b[p] != 1) {
        d[p << 1] = d[p << 1] * qpow(b[p], m - s + 1) % MOD;
        d[p << 1 | 1] = d[p << 1 | 1] * qpow(b[p], t - m) % MOD;
        b[p << 1] = b[p << 1] * b[p] % MOD;
        b[p << 1 | 1] = b[p << 1 | 1] * b[p] % MOD;
        b[p] = 1;
    }

    LL res = 1;
    if (l <= m) res = res * getsum(l, r, s, m, p << 1) % MOD;
    if (r > m) res = res * getsum(l, r, m + 1, t, p << 1 | 1) % MOD;
    return res;
}

int main() {
    std::ios::sync_with_stdio(false);
    LL q, op, x, y, val;
    std::cin >> n >> q;
    for (LL i = 1; i <= n; ++i) std::cin >> a[i];
    build(1, n, 1);
    while (q--) {
        std::cin >> op >> x >> y;
        if (op == 2)
            std::cout << getsum(x, y, 1, n, 1) << "\n";
        else {
            std::cin >> val;
            update(x, y, val, 1, n, 1);
        }
    }
    return 0;
}







操作 1： 格式：1 x y k 含义：将区间 [x,y] 内每个数乘上 k。

操作 2： 格式：2 x y k 含义：将区间 [x,y] 内每个数加上 k。

操作 3： 格式：3 x y 含义：输出区间 [x,y] 内每个数的和对 m 取模所得的结果。




#include <iostream>
#include <vector>
using namespace std;

using LL = long long;
const int N = 1e5 + 5;

LL a[N];
LL sum[N << 2], add[N << 2], mul[N << 2]; // 线段树
int n, q;
LL MOD;

void pushup(int p) {
    sum[p] = (sum[p << 1] + sum[p << 1 | 1]) % MOD;
}

void build(int l, int r, int p) {
    add[p] = 0;
    mul[p] = 1;
    if (l == r) {
        sum[p] = a[l] % MOD;
        return;
    }
    int m = (l + r) >> 1;
    build(l, m, p << 1);
    build(m + 1, r, p << 1 | 1);
    pushup(p);
}

void pushdown(int p, int l, int r) {
    int m = (l + r) >> 1;
    int lc = p << 1, rc = p << 1 | 1;
    // 先更新子节点乘法、再加法（顺序不能反）
    sum[lc] = (sum[lc] * mul[p] % MOD + (m - l + 1) * add[p] % MOD) % MOD;
    sum[rc] = (sum[rc] * mul[p] % MOD + (r - m) * add[p] % MOD) % MOD;

    mul[lc] = mul[lc] * mul[p] % MOD;
    mul[rc] = mul[rc] * mul[p] % MOD;

    add[lc] = (add[lc] * mul[p] % MOD + add[p]) % MOD;
    add[rc] = (add[rc] * mul[p] % MOD + add[p]) % MOD;

    mul[p] = 1;
    add[p] = 0;
}

void range_mul(int L, int R, LL val, int l, int r, int p) {
    if (L <= l && r <= R) {
        sum[p] = sum[p] * val % MOD;
        mul[p] = mul[p] * val % MOD;
        add[p] = add[p] * val % MOD;
        return;
    }
    pushdown(p, l, r);
    int m = (l + r) >> 1;
    if (L <= m) range_mul(L, R, val, l, m, p << 1);
    if (R > m)  range_mul(L, R, val, m + 1, r, p << 1 | 1);
    pushup(p);
}

void range_add(int L, int R, LL val, int l, int r, int p) {
    if (L <= l && r <= R) {
        sum[p] = (sum[p] + (r - l + 1) * val % MOD) % MOD;
        add[p] = (add[p] + val) % MOD;
        return;
    }
    pushdown(p, l, r);
    int m = (l + r) >> 1;
    if (L <= m) range_add(L, R, val, l, m, p << 1);
    if (R > m)  range_add(L, R, val, m + 1, r, p << 1 | 1);
    pushup(p);
}

LL query_sum(int L, int R, int l, int r, int p) {
    if (L <= l && r <= R) return sum[p];
    pushdown(p, l, r);
    int m = (l + r) >> 1;
    LL res = 0;
    if (L <= m) res = (res + query_sum(L, R, l, m, p << 1)) % MOD;
    if (R > m)  res = (res + query_sum(L, R, m + 1, r, p << 1 | 1)) % MOD;
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    cin >> n >> q >> MOD;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    build(1, n, 1);

    while (q--) {
        int op, l, r;
        LL k;
        cin >> op;
        if (op == 1) {
            cin >> l >> r >> k;
            range_mul(l, r, k, 1, n, 1);
        } else if (op == 2) {
            cin >> l >> r >> k;
            range_add(l, r, k, 1, n, 1);
        } else if (op == 3) {
            cin >> l >> r;
            cout << query_sum(l, r, 1, n, 1) << '\n';
        }
    }

    return 0;
}
