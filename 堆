vector<int> v = {3, 1, 4, 2};
sort(v.begin(), v.end(), greater<int>());//从大到小



 priority_queue<int> pq;  // 默认就是大根堆top为最大值



 // 小根堆：最小值优先
    priority_queue<int, vector<int>, greater<int>> pq;


 
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

struct Node {
    int val, id;
};

int main() {
    // 小根堆：先按 val 升序，再按 id 升序
    auto cmp = [](const Node& a, const Node& b) {
        if (a.val != b.val) return a.val > b.val; // 小的 val 优先
        return a.id > b.id;                       // val 相同，id 小的优先
    };

    // 注意 decltype(cmp) 和初始化器
    priority_queue<Node, vector<Node>, decltype(cmp)> pq(cmp);

    pq.push({3, 2});
    pq.push({1, 5});
    pq.push({1, 3});
    pq.push({2, 4});

    while (!pq.empty()) {
        auto top = pq.top();
        cout << "val: " << top.val << ", id: " << top.id << endl;
        pq.pop();
    }

    /*
    输出：
    val: 1, id: 3
    val: 1, id: 5
    val: 2, id: 4
    val: 3, id: 2
    */
}


