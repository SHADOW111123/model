vector<int> v = {3, 1, 4, 2};
sort(v.begin(), v.end(), greater<int>());//从大到小



 priority_queue<int> pq;  // 默认就是大根堆top为最大值



 // 小根堆：最小值优先
    priority_queue<int, vector<int>, greater<int>> pq;


 
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

struct Node {
    int val, id;
};

int main() {
    // 小根堆：先按 val 升序，再按 id 升序
    auto cmp = [](const Node& a, const Node& b) {
        if (a.val != b.val) return a.val > b.val; // 小的 val 优先
        return a.id > b.id;                       // val 相同，id 小的优先
    };

    // 注意 decltype(cmp) 和初始化器
    priority_queue<Node, vector<Node>, decltype(cmp)> pq(cmp);

    pq.push({3, 2});
    pq.push({1, 5});
    pq.push({1, 3});
    pq.push({2, 4});

    while (!pq.empty()) {
        auto top = pq.top();
        cout << "val: " << top.val << ", id: " << top.id << endl;
        pq.pop();
    }

    /*
    输出：
    val: 1, id: 3
    val: 1, id: 5
    val: 2, id: 4
    val: 3, id: 2
    */
}

set逆序排序
#include <iostream>
#include <set>
using namespace std;

int main() {
    // 定义lambda表达式作为比较器，实现降序排序
    auto comp = [](int a, int b) {
        return a > b; // 降序排列
        };

    // 定义逆序排序的multiset（允许重复元素）
    multiset<int, decltype(comp)> ms(comp);

    // 插入元素（包含重复值）
    ms.insert(5);
    ms.insert(3);
    ms.insert(5); // 重复元素
    ms.insert(7);
    ms.insert(3); // 重复元素
    ms.insert(1);

    // 遍历输出，会按 7,5,5,3,3,1 顺序打印
    for (int num : ms) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}

